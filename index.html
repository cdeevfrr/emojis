
<body>
    <div style="justify-content: center; text-align: center; display: flex">
        <div>
            <p id="leftNotification" style="height: 100px"></p>
            <p>
                Move with asdw
            </p>
            <p>
                Grow (enter) or Harvest (h) your crops!
            </p>
        </div>
        <textarea id="mainScreen" readonly style="height:8.6em; width: 7.2em ; font-size: 10vmin; text-align: center; margin:auto">
        </textarea>
        <div>
            <p id="rightNotification" style="height: 100px"></p>
            <p>T gives a little bit of energy üòâ</p>
        </div>

    </div>
    <div style="text-align: center; justify-content: center;">
        <div>
            <p id="playerStats" style="color: green"></p>
        </div>
    </div>
</body>


<script>
const maxEntityEnergy = 100

const imageFor = {
    0: "_",
    // 1: Crop image
    9: "‚ñì",
}

const cropImages = {
    1: ".",
    2: ",",
    3: "+",
    4: "i",
    5: "l",
    6: ")",
    7: "|",
    8: "T",
}

class Crop{
    stage;
    maxStage;
    constructor(){}

    toJSON(){
        return {
            [this.constructor.name]: {
                stage: this.stage, 
                maxStage: this.maxStage,
            }
        }
    }

    blocksMovement(){
        return 7 <= this.stage && this.stage <=8
    }

    harvestCost(){
        if (this.stage > this.maxStage){
            return 2
        }
        return 1
    }

    canHarvest(){
        return this.stage > 3
    }

    moneyGain(){
        if(this.stage > this.maxStage){
            return 0
        }
        return 4
    }

    newStageFromHarvest(){
        if(this.stage > this.maxStage){
            return -1
        }
        return this.stage - 4
    }

    canAutoGrow(){
        return this.stage >= 3 && this.stage < this.maxStage
    }

    grow(){
        this.stage += 1
    }

    harvest(harvestingEntity){
        if( harvestingEntity.tryDecrementEnergy(this.harvestCost()) ){
            harvestingEntity.increaseMoney(this.moneyGain())
            this.stage = this.newStageFromHarvest()
        }
    }

    image(){
        if (this.stage in cropImages){
            return cropImages[this.stage]
        }
        return "#"
    }
}

class BaseCrop extends Crop{
    constructor({stage, maxStage} = {stage: 1, maxStage: 8}){
        super()
        this.stage = stage || 1
        this.maxStage = maxStage || 8
    }

    moneyGain(){
        if(this.stage == 7){
            return 8
        }
        return super.moneyGain() 
    }

    harvestCost(){
        if(this.stage == 8){
            return -1 // If fully grown, you get 1 energy back.
        }
        return super.harvestCost()
    }
}

const crops = {
    "BaseCrop": BaseCrop,
}

function parseMap(text){
    // the second arg will read any crops as actual crops.
    const newMap = JSON.parse(text)
    for (row of newMap){
        for(let i = 0; i < row.length; i ++){
            for(key in row[i]){
                if (key in crops){
                    row[i] = new (crops[key])(row[i][key])
                }
            }
        }
    }
    return newMap
}

const directions = {
    a: {x: -1, y: 0},
    s: {x: 0,  y: 1},
    d: {x: 1,  y: 0},
    w: {x: 0,  y: -1},
}

class Entity{
    direction;
    money;
    energy;
    location;

    move(directionKey){
        this.direction = directionKey
        const newLocation = this.interactingLocation()

        const canMoveThere = this.canMove(newLocation.x, newLocation.y)

        if(canMoveThere){
            this.location.x = newLocation.x
            this.location.y = newLocation.y
        }
    }

    canMove(x, y){
        return 0 <= y && y < map.length 
        && 0 <= x && x < map[y].length 
        && ! blockingMovementTiles.has(map[y][x])
        && ( map[y][x] in imageFor || 
          (map[y][x] instanceof Crop && !map[y][x].blocksMovement())
        );
    }

    tryDecrementEnergy(amount){
        if (this.energy > amount){
            this.energy -= amount
            return true
        }
        return false
    }

    increaseMoney(amount){
        return
    }

    harvest(){
        const targetLocation = this.interactingLocation()
        console.log(`Handling harvest interaction at ${JSON.stringify(targetLocation)}`)
        let target = map[targetLocation.y]?.[targetLocation.x]

        if (target == null){
            return
        }

        if(target instanceof Crop){
            if(target.canHarvest()){
                target.harvest(this) // the crop will decrement the entity's energy.
                if (target.stage == -1){
                    map[targetLocation.y][targetLocation.x] = 0
                }
            }
        }
    }

    grow(){
        const targetLocation = this.interactingLocation()
        console.log(`Handling grow interaction at ${JSON.stringify(targetLocation)}`)

        const target = map[targetLocation.y]?.[targetLocation.x]

        if (target instanceof Crop){
            if (this.energy < 1){
                return
            }
            this.energy -= 1

            target.grow()
        }
    }

    interactingLocation(){
        const toAdd = directions[this.direction]

        return {
            x: this.location.x + toAdd.x,
            y: this.location.y + toAdd.y,
        }
    }
}

class Farmer extends Entity{

}

const mapString2 = '[[9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9],[9,0,0,{"BaseCrop":{"stage":1,"maxStage":8}},0,0,0,0,{"BaseCrop":{"stage":1,"maxStage":8}},{"BaseCrop":{"stage":1,"maxStage":8}},{"BaseCrop":{"stage":1,"maxStage":8}},0,0,0,0,0,0,0,0],[9,0,{"BaseCrop":{"stage":1,"maxStage":8}},0,0,0,{"BaseCrop":{"stage":5,"maxStage":8}},0,{"BaseCrop":{"stage":1,"maxStage":8}},{"BaseCrop":{"stage":1,"maxStage":8}},{"BaseCrop":{"stage":1,"maxStage":8}},0,0,0,0,0,0,{"BaseCrop":{"stage":8,"maxStage":8}},0],[9,0,0,0,{"BaseCrop":{"stage":2,"maxStage":8}},0,{"BaseCrop":{"stage":5,"maxStage":8}},0,{"BaseCrop":{"stage":2,"maxStage":8}},{"BaseCrop":{"stage":1,"maxStage":8}},{"BaseCrop":{"stage":1,"maxStage":8}},0,0,0,0,0,0,{"BaseCrop":{"stage":8,"maxStage":8}},0],[9,0,0,0,0,0,{"BaseCrop":{"stage":5,"maxStage":8}},0,{"BaseCrop":{"stage":1,"maxStage":8}},{"BaseCrop":{"stage":1,"maxStage":8}},{"BaseCrop":{"stage":1,"maxStage":8}},0,0,0,0,0,0,{"BaseCrop":{"stage":8,"maxStage":8}},0],[9,{"BaseCrop":{"stage":1,"maxStage":8}},0,0,0,0,0,0,{"BaseCrop":{"stage":1,"maxStage":8}},{"BaseCrop":{"stage":1,"maxStage":8}},{"BaseCrop":{"stage":1,"maxStage":8}},0,0,0,0,0,0,{"BaseCrop":{"stage":8,"maxStage":8}},0]]'
const map = parseMap(mapString2)

const defaultWidth = 11
const defaultHeight= 7

const blockingMovementTiles = new Set([
    9,
])

// You can only harvest between values 5 and 8 (inclusive)
// Harvesting reduces size by 4
// Things only grow by themselves between 3 and 7 (inclusive)
// So harvesting at 5 or 6 is detrimental - you should wait for 7 or 8.

/// Begin async stuff
window.onload = async function(){
    
    /**
     * @type HTMLTextAreaElement
     */ 
    const mainScreen = document.getElementById("mainScreen")
    const playerStats = document.getElementById("playerStats")
    const leftNotification = document.getElementById("leftNotification")
    const rightNotification = document.getElementById("rightNotification")


    mainScreen.onclick = () => {
        mainScreen.requestPointerLock()
    }

    // Pointer lock listers
    document.addEventListener('pointerlockchange',pointerLockChangeListener, false);
    let tickInterval = null

    function pointerLockChangeListener(){
        if (document.pointerLockElement === mainScreen){
            console.log("Adding listeners")
            mainScreen.addEventListener('keydown', handleKeypress)
            tickInterval = tickInterval ||  setInterval(tick, 1000)
        } else {
            console.log("Removing listeners")
            mainScreen.removeEventListener('keydown', handleKeypress, true)

            if(tickInterval){
                clearInterval(tickInterval)
                tickInterval = null
            }
        }
    }

    const playerIcon = {
        "d": "üòó",
        "s": "üôÉ",
        "a": "üßê",
        "w": "üôÇ",
    }

    class Player extends Entity{
        constructor(){
            super()
            this.location = {x: 3, y: 3}
            this.direction = "d"
            this.money = 0
            this.energy = 40
        }

        increaseMoney(amount){
            this.money += amount
            notify(`+ $${amount}`)
        }
    }

    const player = new Player()

    // End pointer lock listeners

    function printLocation({
        x = player.location.x, 
        y = player.location.y, 
        width = defaultWidth, 
        height = defaultHeight
    }){
        const toPrint = []
        // the point (x=0, y=0) is the top left. Positive y is down.
        for (let j = y - Math.floor(height/2); j < y + Math.ceil(height / 2); j += 1){
            const row = []
            for (let i = x- Math.floor(width/2); i < x + Math.ceil(width / 2); i+=1){
                row.push(findImageFor(map[j]?.[i]))
            }
            toPrint.push(row)
        }
        // Show the player in the center instead.
        toPrint[Math.floor(height / 2)][Math.floor(width / 2)] = playerIcon[player.direction]

        mainScreen.value = toPrint.map(row => row.join("")).join("\n")

        playerStats.innerText = `Money: \$${player.money}  Energy: ${Math.floor(player.energy)}`
    }

    function findImageFor(mapElement){
        if (mapElement in imageFor){
            return imageFor[mapElement]
        }

        if (mapElement instanceof Crop){
            return mapElement.image()
        }

        return "0"
    }



    /**
     * @param {KeyboardEvent} event 
     */ 
    function handleKeypress(event){
        console.log(`"Got event ${event.key}`)

        if (event.key in directions){
            player.move(event.key)
        }

        if (event.key == "Enter"){
            player.grow()
        }

        if (event.key == "h"){
            player.harvest()
        }

        printLocation({})
    }

    /**
     * @type 
     */ 
    let endNotificationTimer = null
    function notify(toNotify){
        leftNotification.innerText = toNotify
        rightNotification.innerText = toNotify

        if (endNotificationTimer){
            clearTimeout(endNotificationTimer)
        }
        endNotificationTimer = setTimeout(endNotification, 1000)
    }

    function endNotification(){
        leftNotification.innerText = ""
        rightNotification.innerText = ""
        endNotificationTimer = null
    }

    function tick(){
        console.log("Running tick");
        // Grow things
        for (const row of map){
            for (const target of row){
                if (target.canAutoGrow && target.canAutoGrow()){
                    if (Math.random() < .08){
                        target.grow()
                    }
                }
            }
        }
        // Gain energy
        player.energy += .25
        if (player.energy > maxEntityEnergy){
            player.energy = maxEntityEnergy
        }

        printLocation({})
    }


    printLocation({})
}
</script>
